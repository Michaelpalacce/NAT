import { execa } from "execa";
import { ArtifactData } from "../helpers/maven/artifact.js";
import { CliOptions } from "../arguments.js";
import logger from "../logger/logger.js";
import { getCertificates } from "../helpers/fs/locations.js";

/**
* This method runs both vropkg tree and flat. This will package the entire solution to a .package file
* @TODO: Better certificate resolution... at the very least detect the one in the target folder... best case use a file system path?
*/
export default async function(args: CliOptions, artifactData: ArtifactData) {
	const { outFolder } = args;
	const { artifactId, groupId, version } = artifactData;

	logger.info("Running vropkg: tree");
	await execa('vropkg', [
		'--in',
		'js',
		'--srcPath', `${outFolder}/vro-sources/js`,
		'--out', 'tree',
		'--destPath', `${outFolder}/vro-sources/xml`,
		'--privateKeyPEM', getCertificates().privateKeyPem,
		'--certificatesPEM', getCertificates().certPem,
		'--keyPass', 'VMware1!',
		'--version', version,
		'--packaging', 'package',
		'--artifactId', artifactId,
		'--groupId', groupId,
		'--description', 'Generated By NAT ;)',
	]);
	logger.info("Done running vropkg: tree");

	logger.info("Running vropkg: flat");
	await execa('vropkg', [
		'--in', 'tree',
		'--srcPath', `${outFolder}/vro-sources/xml`,
		'--out', 'flat',
		'--destPath', `${outFolder}/vropkg`,
		'--privateKeyPEM', getCertificates().privateKeyPem,
		'--certificatesPEM', getCertificates().certPem,
		'--keyPass', 'VMware1!',
		'--version', version,
		'--packaging', 'package',
		'--artifactId', artifactId,
		'--groupId', groupId,
		'--description', 'Generated By NAT ;)',
	]);
	logger.info("Done running vropkg: flat");
}
